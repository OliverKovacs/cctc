use clap::{App, Arg, ArgMatches};

pub fn app() -> ArgMatches {
    App::new("cctc")
        .version("0.1")
        .author("Oliver Kovacs <oliver.kovacs.dev@gmail.com>")
        .about("Command-line application for cracking columnar transposition ciphers")
        .subcommand(App::new("encrypt")
            .arg(Arg::new("PLAINTEXT")
                .help("The plaintext to be encrypted")
                .required(true)
            )
            .arg(Arg::new("KEY")
                .help("The key used for encryption")
                .required(true)
            )
        )
        .subcommand(App::new("decrypt")
            .arg(Arg::new("CIPHER")
                .help("The ciphertext to be decrypted")
                .required(true)
            )
            .arg(Arg::new("KEY")
                .help("The key used for decryption")
                .required(true)
            )
        )
        .subcommand(App::new("crack")
            .about("Crack a columnar transposition cipher")
            .arg(Arg::new("CIPHER")
                .help("The ciphertext")
                .takes_value(true)
                .required(true)
                .requires("COLUMNS")
            )
            .arg(Arg::new("FILE")
                .help("File with pregenerated decryptet values")
                .long("file")
                .short('f')
                .takes_value(true)
                .conflicts_with("CIPHER")
                .takes_value(true)
                .required(true)
            )
            .arg(Arg::new("COLUMNS")
                .help("The column widths used for encryption")
                .long("columns")
                .short('c')
                .takes_value(true)
            )
            .arg(Arg::new("DICTONARY")
                .help("Path to dictonary file")
                .long("dictonary")
                .short('d')
                .takes_value(true)
                .required(true)
            )
            .arg(Arg::new("OUTPUT")
                .help("Output file")
                .long("out")
                .short('o')
                .default_value("out")
                .takes_value(true)
            )
            .arg(Arg::new("LIST_OUTPUT")
                .help("Output file for intermediate list of possible solutions")
                .long("list_out")
                .short('l')
                .takes_value(true)
            )
            .arg(Arg::new("FILTER_BEGINS_WITH_SPACE")
                .help("Filter results that begin with a space")
                .long("f_begins_with_space")
                .short('b')
            )
            .arg(Arg::new("FILTER_DOUBLE_SPACE")
                .help("Filter results that contain two or more consecutive spaces not at the end")
                .long("f_double_space")
                .short('s')
            )
            .arg(Arg::new("FILTER_NO_VOWELS")
                .help("Filter results that contain words without vowels")
                .long("f_no_vowels")
                .short('v')
            )
            .arg(Arg::new("FILTER_MUST_CONTAIN")
                .help("Filter results that don't contain the given substring")
                .long("f_must_contain")
                .short('i')
                .takes_value(true)
            )
        )
        .get_matches()
}
